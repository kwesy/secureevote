from core.mixins.serializer import RestrictUpdateFieldsMixin
from core.models.ticket import Ticket, TicketSale
from rest_framework import serializers
from .models.user import User
from .models.event import Event
from .models.candidate import Candidate
from .models.category import Category

PAYMENT_METHOD_CHOICES = [('momo', 'Mobile Money'), ('card', 'Card'), ('bank', 'Bank')]
PROVIDER_CHOICES = [('mtn', 'MTN'), ('airtel', 'Airtel'), ('telecel', 'Telecel')]

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'email', 'organization_name', 'is_verified', 'is_active', 'balance']

class CandidateSerializer(serializers.ModelSerializer):
    revenue = serializers.SerializerMethodField()
    def get_revenue(self, obj):
        """
        Returns the revenue generated by the candidate based on the votes received.
        """
        return obj.vote_count * obj.event.amount_per_vote if obj.event else 0
    
    class Meta:
        model = Candidate
        fields = ['id', 'name', 'gender', 'photo', 'description', 'vote_count', 'is_blocked', 'event', 'category', 'revenue', 'achivements', 'extra_info' ]
        read_only_fields = ['vote_count']

class PublicCandidateSerializer(serializers.ModelSerializer):
    
    class Meta:
        model = Candidate
        fields = ['id', 'name', 'gender', 'photo', 'description', 'vote_count', 'event', 'category', 'achivements', 'extra_info' ]
        read_only_fields = fields

# Category Serializer

class CategorySerializer(serializers.ModelSerializer):
    total_votes = serializers.SerializerMethodField()
    total_candidates = serializers.SerializerMethodField()
    
    def get_total_votes(self, obj):
        """
        Returns the total number of votes for all candidates in the category.
        """
        return sum(candidate.vote_count for candidate in obj.candidates.all())

    def get_total_candidates(self, obj):
        """
        Returns the total number of candidates in the category.
        """
        return obj.candidates.count()
    

    class Meta:
        model = Category
        fields = ["id", "event", "name", "description", "is_active", 'total_candidates', 'total_votes']

    def update(self, instance, validated_data):
        """
        Update the category instance with the provided data.
        """
        instance.name = validated_data.get('name', instance.name)
        instance.description = validated_data.get('description', instance.description)
        instance.is_active = validated_data.get('is_active', instance.is_active)
        instance.save()
        return instance

class PublicCategorySerializer(serializers.ModelSerializer):
    total_votes = serializers.SerializerMethodField()
    total_candidates = serializers.SerializerMethodField()
    
    def get_total_votes(self, obj):
        """
        Returns the total number of votes for all candidates in the category.
        """
        return sum(candidate.vote_count for candidate in obj.candidates.all())

    def get_total_candidates(self, obj):
        """
        Returns the total number of candidates in the category.
        """
        return obj.candidates.count()

    class Meta:
        model = Category
        fields = ["id", "event", "name", "description", 'total_candidates', 'total_votes']
        read_only_fields = ["id", "event", "name", "description", 'total_candidates', 'total_votes']

#Event Serializer

class EventSerializer(serializers.ModelSerializer):
    total_votes = serializers.SerializerMethodField()
    revenue = serializers.SerializerMethodField()
    total_candidates = serializers.SerializerMethodField()

    def get_total_votes(self, obj):
        return sum(candidate.vote_count for category in obj.categories.all() for candidate in category.candidates.all())
    
    def get_revenue(self, obj):
        return obj.amount_per_vote * self.get_total_votes(obj)
    
    def get_total_candidates(self, obj):
        """
        Returns the total number of candidates across all categories in the event.
        """
        return sum(category.candidates.count() for category in obj.categories.all())
    

    class Meta:
        model = Event
        fields = [
            'id', 'name', 'description', 'shortcode',
            'amount_per_vote', 'start_time', 'end_time', 'host', 'location',
            'is_active', 'is_blocked', 'total_candidates', 'total_votes', 'revenue',
        ]

class PublicEventSerializer(serializers.ModelSerializer):
    number_of_category = serializers.SerializerMethodField()

    def get_number_of_category(self, obj):
        """
        Returns the number of categories associated with the event.
        """
        return obj.categories.count()

    class Meta:
        model = Event
        fields = [
            'id', 'name', 'description', 'shortcode', 'start_time',
            'end_time', 'number_of_category', 'host', 'location'
        ]

# Serializer for Tickets
class TicketSerializer( RestrictUpdateFieldsMixin, serializers.ModelSerializer):
    class Meta:
        model = Ticket
        fields = ['id', 'event', 'price', 'type', 'quantity', 'sold', 'desc', 'is_active', 'created_at']
        read_only_fields = ['id', 'sold', 'created_at']
        updatable_fields = ['price', 'type', 'quantity', 'desc', 'is_active']
        
class TicketSaleSerializer(serializers.ModelSerializer):
    phone_number = serializers.CharField(max_length=15, write_only=True)
    amount = serializers.DecimalField(max_digits=10, decimal_places=2, read_only=True)
    payment_method = serializers.ChoiceField(choices=PAYMENT_METHOD_CHOICES, write_only=True)
    provider = serializers.ChoiceField(choices=PROVIDER_CHOICES, write_only=True)

    def validate_amount(self, value):
        if value <= 0:
            raise serializers.ValidationError("Amount must be greater than zero.")
        return value

    class Meta:
        model = TicketSale
        fields = ['id', 'ticket', 'customer_name', 'recipient_contact', 
                  'phone_number', 'amount', 'payment_method', 'provider',] # payment details
        read_only_fields = ['id', 'created_at', 'payment']
