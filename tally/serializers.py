from core.models.candidate import Candidate
from core.models.category import Category
from rest_framework import serializers
from django.utils.timezone import now


class CandidateSerializer(serializers.ModelSerializer):
    vote_amount = serializers.SerializerMethodField(read_only=True)
    rank = serializers.SerializerMethodField(read_only=True)
    
    def get_vote_amount(self, obj):
        """
        Returns the total amount generated by the votes for the candidate.
        """
        return obj.vote_count * obj.event.amount_per_vote if obj.event else 0
    
    def get_rank(self, obj):
        """
        Returns the rank of the candidate based on the vote count.
        """
        # Get all candidates in the same event, ordered by vote count descending
        candidates = Candidate.objects.filter(event=obj.event).order_by('-vote_count', 'name')
        rank = 1
        for candidate in candidates:
            if candidate.id == obj.id:
                return rank
            rank += 1
        return None

    class Meta:
        model = Candidate
        fields = [ "id", "name", "rank", "vote_count", "vote_amount"]
        read_only_fields = ["id", "vote_count", "vote_amount", "rank"]

class CategoryResultSerializer(serializers.ModelSerializer):
    results = CandidateSerializer(source='candidates', many=True, read_only=True)
    last_update = serializers.SerializerMethodField(read_only=True)

    def get_last_update(self, obj):
        """
        Returns the last update time in a human-readable
        format.
        """
        return now().strftime('%Y-%m-%d %H:%M:%S')

    class Meta:
        model = Category
        fields = ["id", "event", "last_update", "results"]
        read_only_fields = ["id", "event", "results"]
